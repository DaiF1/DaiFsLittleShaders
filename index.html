<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/vite.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>DaiF's Little Shaders</title>
    </head>
    <body>
        <select id="shader-select">
            <option value="default" selected>Default</option>
            <option value="gooch">Gooch</option>
            <option value="comics">Comics</option>
        </select>
        <canvas id="c"></canvas>
        <script type="module" src="/main.js"></script>
        <script id="default-vertex" type="shader/vertex">
            attribute vec4 a_position;
            attribute vec2 a_texcoord;
            attribute vec3 a_normal;

            uniform mat4 u_worldViewMatrix;
            uniform mat4 u_world;

            varying vec2 v_texcoord;
            varying vec3 v_normal;

            void main() {
                gl_Position = u_worldViewMatrix * a_position;

                v_texcoord = a_texcoord;
                v_normal = mat3(u_world) * a_normal;
            }
        </script>

        <script id="default-fragment" type="shader/fragment">
            precision mediump float;

            varying vec2 v_texcoord;
            varying vec3 v_normal;

            uniform sampler2D u_texture;
            uniform vec3 u_reverseLightDir;

            void main() {
                vec3 normal = normalize(v_normal);
                float light = (1.0 + dot(normal, u_reverseLightDir)) / 2.0;

                gl_FragColor = texture2D(u_texture, v_texcoord);
                gl_FragColor.rgb *= light;
            }
        </script>

        <script id="vertex-depth" type="shader/vertex">
            attribute vec4 a_position;
            attribute vec3 a_normal;

            uniform mat4 u_worldViewMatrix;
            uniform mat4 u_world;

            varying float v_depth;
            varying vec3 v_normal;

            void main() {
                gl_Position = u_worldViewMatrix * a_position;

                v_depth = gl_Position.z;
                v_normal = mat3(u_world) * a_normal;
            }
        </script>

        <script id="fragment-depth" type="shader/fragment">
            precision mediump float;

            varying float v_depth;
            varying vec3 v_normal;

            void main() {
                vec3 color = vec3(0, 0, 0);
                gl_FragColor = vec4(color, 1);
            }
        </script>

        <script id="gooch-fragment" type="shader/fragment">
            precision mediump float;

            varying vec2 v_texcoord;
            varying vec3 v_normal;

            uniform sampler2D u_texture;
            uniform vec3 u_reverseLightDir;

            void main() {
                vec3 normal = normalize(v_normal);
                float light = (1.0 + dot(normal, u_reverseLightDir)) / 2.0;
                vec4 color = texture2D(u_texture, v_texcoord);

                float alpha = 0.2;
                float beta = 0.4;
                vec3 coolColor = vec3(129.0 / 255.0, 188.0 / 255.0, 230.0 / 255.0);
                vec3 warmColor = vec3(230.0 / 255.0, 189.0 / 255.0, 129.0 / 255.0);

                vec3 kCool = coolColor + vec3(alpha) * color.xyz;
                vec3 kWarm = warmColor + vec3(beta) * color.xyz;

                vec3 gooch = (light * kWarm) + ((1.0 - light) * kCool);
                gl_FragColor = vec4(gooch, 1);
            }
        </script>

        <script id="comics-fragment" type="shader/fragment">
            precision mediump float;

            varying vec2 v_texcoord;
            varying vec3 v_normal;

            uniform sampler2D u_texture;
            uniform vec3 u_reverseLightDir;

            void main() {
                // color
                vec3 normal = normalize(v_normal);
                float light = (1.0 + dot(normal, u_reverseLightDir)) / 2.0;
                vec4 color = texture2D(u_texture, v_texcoord);

                vec3 shadow = vec3(0.5, 0.5, 0.8);
                float f = step(0.2, light) * (0.5 * step(0.4, light) + 0.5);
                vec3 col = vec3(f) * color.xyz + vec3(1.0 - f) * color.xyz * shadow.xyz;

                gl_FragColor = vec4(col, 1);
            }
        </script>

        <script id="default-vertex-postp" type="shader/vertex">
            attribute vec4 a_position;
            attribute vec2 a_texcoord;

            varying vec2 v_texcoord;

            void main() {
                gl_Position = a_position;
                v_texcoord = a_texcoord;
            }
        </script>

        <script id="default-fragment-postp" type="shader/fragment">
            precision mediump float;

            varying vec2 v_texcoord;

            uniform sampler2D u_screenTexture;

            void main() {
                gl_FragColor = texture2D(u_screenTexture, v_texcoord);
            }
        </script>

        <script id="outline-fragment-postp" type="shader/fragment">
            precision mediump float;

            varying vec2 v_texcoord;

            uniform sampler2D u_depthTexture;
            uniform sampler2D u_screenTexture;
            uniform float u_width;
            uniform float u_height;

            void main() {
                const int outlineWidth = 7;
                float m[outlineWidth * outlineWidth];

                for (int i = 0; i < outlineWidth; i++) {
                    for (int j = 0; j < outlineWidth; j++) {
                        vec3 n[9];
                        float w = 1.0 / u_width;
                        float h = 1.0 / u_height;
                        for (int y = 0; y < 3; y++) {
                            for (int x = 0; x < 3; x++) {
                                n[y * 3 + x] = texture2D(u_depthTexture, v_texcoord +
                                    vec2(float(i - 1 + x - 1) * w, float(j - 1 + y - 1) * h)).rgb;
                            }
                        }

                        vec3 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);
                        vec3 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);
                        vec3 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));

                        float lumi = float(2.0 * sobel.r + sobel.b + 3.0 * sobel.g) / 6.0;
                        m[j * outlineWidth + i] = 1.0 - step(0.2, lumi);
                    }
                }

                float edge = m[0];
                for (int i = 1; i < outlineWidth * outlineWidth; i++) {
                    edge = min(m[i], edge);
                }

                vec3 color = vec3(edge) * texture2D(u_screenTexture, v_texcoord).rgb;
                gl_FragColor = vec4(color, 1.0);
            }
        </script>
    </body>
</html>
